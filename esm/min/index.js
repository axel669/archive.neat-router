import{useState as t,useMemo as n,useEffect as e,Children as r}from"react";function o(){return(o=Object.assign||function(t){for(var n=1;n<arguments.length;n++){var e=arguments[n];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])}return t}).apply(this,arguments)}const l=t=>{const n=t.slice(1).split("/").map(t=>{const n=t.match(/^((?<path>\w+)|(:(?<name>\w+)(\((?<regex>.+?)\))?)|(\*(?<rest>\w+$)))$/);if(null===n)return null;const{groups:e}=n;if(void 0!==e.path)return([t,...n])=>t===e.path?n:null;if(void 0!==e.rest)return(t,n)=>(n[e.rest]=t.join("/"),[]);if(void 0!==e.name){const t=void 0===e.regex?/^.+$/:new RegExp(`^${t}$`);return([n,...r],o)=>void 0!==n&&!0===t.test(n)?(o[e.name]=n,r):null}return null});return n.filter(t=>null===t).length>0?(console.warn(`Invalid route: ${t}`),()=>null):(e,{exact:r}={})=>{const o={};let l=e.slice(1).split("/");for(const t of n)if(null===(l=t(l,o)))return null;return l.length>0&&!0===r?null:{url:e,params:o,route:t}}},s=t=>e(t,[]),u=t=>n(()=>l(t),[t]);function c(n){return{Route:function(e){const[r,l]=t(n.url),{path:c,exact:a,component:i,...h}=e,p=u(c);s(()=>n.subscribe(l));const f=p(r,{exact:a});return null===f?null:React.createElement(i,o({},h,{neat:f}))},Switch:function(e){const[u,c]=t(n.url),{children:a,...i}=e,h=r.toArray(a);s(()=>n.subscribe(c));for(const{props:t}of h){const{path:n,exact:e,component:r,...s}=t,c=l(n)(u,{exact:e});if(null!==c)return React.createElement(r,o({},i,s,{neat:c}))}return null}}}const a=()=>{const t=new Map;return{subscribe:n=>{const e=`${Date.now()}:${Math.random()}`;return t.set(e,n),()=>t.delete(e)},publish:n=>{for(const e of t.values())e(n)}}},i=()=>{const t=a(),n={get hash(){return location.hash.toString().replace(/^#/,"")},get subscribe(){return t.subscribe},get url(){return n.hash}};n.initialState=n.hash;let e=n.hash;return setInterval(()=>{const r=n.hash;r!==e&&(e=r,t.publish(r))},50),n};export{i as HashPublisher,a as Publisher,c as Router};
